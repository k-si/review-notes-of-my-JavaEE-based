第一章：线程

知识点1：程序、进程、线程是什么？有什么区别？
        1、他们是什么？
            程序是静态概念，因为程序指代的是写好的代码，一段完整的代码我们可以称之为程序。
            进程、线程是动态概念。一个在执行中的程序可以称之为一个进程，比如在听的QQ音乐，这就是后台运行的
            一个进程。比如你一边听着歌，一边浏览着QQ音乐里的歌单，这样同时进行的操作就属于多线程的范畴，QQ音乐
            是一个运行中的进程，它一边服务你听音乐，一边服务你看歌单，这两个行为可以称作两个线程。所以很明显了，
            进程包括线程，进程是一个更大的概念，而线程是进程的细分。

        2、进程、线程有什么区别？
            第一点，我们可以在范围上理解：一个进程包括多个线程。
            第二点，在占用的系统资源方面：每个进程都有自己的一块内存空间，一组系统资源。并且线程的数据存放于
                寄存器、进程创建的堆栈中。很明显进程使用的资源要比线程大的多，所以进程的切换要比线程的切换耗费
                的资源要多，负荷更大。
            第三点，进程是独立单位，进程与进程之间的数据是比较独立的，而线程共享一个进程的资源，线程与线程之间
                的数据是共享的，线程是共享单位。

知识点2：多线程的优缺点？
        1、优点？
           第一点，为什么计算机操作系统由单道批处理进化到多线程？这说明多线程工作效率要比单线程高，对数据的吞吐量大。
           第二点，计算机硬件的发展，由单核到多核，多线程可以充分利用硬件资源。
           第三点，用户体验，如果只有单线程，做什么事都要排队，好比你在听音乐时，只能把音乐听完或者暂停音乐
                才能浏览歌单。多线程本身是线程的轮转执行，但是给人的感觉是同时进行多项事情。

        2、缺点？
           第一点，线程切换带来的资源消耗，这部分消耗如果过多，会使多线程的效率大大降低
           第二点，读写的不安全，如果编程不谨慎，回导致同时读写，进而数据异常。
           第三点，发生死锁。
           第四点，多线程共享cpu资源，如果出现需要打印的操作时会造成资源倾斜，占用大量资源，而使得其他程序变慢。

知识点3：线程的生命周期？
        创建、就绪、运行、阻塞、死亡。
        状态的转换、状态的含义。

知识点4：如何创建线程？如何获取线程？（Thread和Runnable）
        直接继承Thread类，创建一个类实现Runnable接口。
        都要重写run方法，使用时调用start方法。
        一般在实现数据共享的例子中使用Runnable。

        使用对象.setName给Runnable对象启动的线程起名
        使用Thread.currentThread()获取当前线程对象名称

知识点5：如何理解线程常用方法？（sleep、yield、join等等）
        Thread.sleep：
            线程睡眠，使线程转为阻塞态，线程会在指定时间到达后苏醒，进入就绪态。一般sleep指定的时间比实际线程开始
            运行的时间要断。
        Thread.yield：
            线程礼让，将正在运行的线程转为就绪态，然后执行同优先级的一个线程。注意yield可能会出现礼让失败，当前线程
            进入就绪态也可能会直接被cpu拉回到运行态。
        new Thread().join：
            线程插队，在一个线程执行中出现另一个线程的join，那么当前线程就被插队了，需要让插队的线程执行完再执行。

        扩展：wait、notify
            首先要说明的是，这两个方法在对象上调用，并且要搭配Synchronized使用。
            wait会将一个线程阻塞，然后等待唤醒，当调用notify方法后，线程又回到就绪态。
            一般适用于生产者消费者同步机制中。

知识点6：Synchronized怎么使用？代码实现一下消费者同步者模型？
        Synchronized：一种重量级锁，是最高级、最安全的锁，但是消耗的资源比较多。上锁后，一个东西在同一时间只能
        被另一个东西使用。保证不出现读写的异常。
        修饰方法：该方法在同一时刻只能由一个线程使用
        修饰类：该类的所有对象在同一时刻只能有一个来使用类中的属性、方法
        修饰代码块：Synchronized(对象或.class){...}

知识点7：什么是死锁？为什么会有死锁发生？
        两个以上的线程的资源争夺导致线程都无法继续执行，除非更新他们的优先级或者新增资源，或者强制终结某个线程等等方法。

        线程A需要资源1，占有资源2
        线程B需要资源2，占有资源1
        两者同时发生，在没有外力的作用下，这两个线程不会结束，一直阻塞。

        又或者是一个线程一直占用某个资源，不释放，导致其他线程无法使用。

        又或者是线程的执行需要上一个线程执行完再执行，这样如果ABC三个线程形成环路，就处于死锁，相互等待上一级完成。



